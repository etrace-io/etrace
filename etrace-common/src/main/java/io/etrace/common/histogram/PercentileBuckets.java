/*
 * Copyright 2019 etrace.io
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.etrace.common.histogram;

import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.function.Function;

/**
 * Bucket values for estimating a percentile from a set of non-negative long values. This class acts as an immutable
 * array of the buckets along with providing some helper functions.
 */
public final class PercentileBuckets {

    // Number of positions of base-2 digits to shift when iterating over the long space.
    private static final int FIRST_DIGITS = 2;
    private static final int Then_DIGITS = 1;
    // Bucket values to use, see static block for initialization.
    private static final long[] BUCKET_VALUES;
    // Keeps track of the positions for even powers of 4 within BUCKET_VALUES. This is used to
    // quickly compute the offset for a long without traversing the array.
    private static final int[] POWER_OF_4_INDEX;

    // The set of buckets is generated by using powers of 4 and incrementing by one-third of the
    // previous power of 4 in between as long as the value is less than the next power of 4 minus
    // the delta.
    //
    // <pre>
    // Base: 1, 2, 3
    //
    // 4 (4^1), delta = 1
    //     5, 6, 7, ..., 14,
    //
    // 16 (4^2), delta = 5
    //    21, 26, 31, ..., 56,
    //
    // 64 (4^3), delta = 21
    // ...
    // </pre>
    static {
        ArrayList<Integer> powerOf4Index = new ArrayList<>();
        powerOf4Index.add(0);

        ArrayList<Long> buckets = new ArrayList<>();
        buckets.add(1L);
        buckets.add(2L);
        buckets.add(3L);

        int digits = FIRST_DIGITS;
        int denominator = 3;
        int exp = FIRST_DIGITS;
        while (exp < 64) {
            long current = 1L << exp;
            long delta = current / denominator;
            long next = (current << digits) - delta;

            powerOf4Index.add(buckets.size());
            while (current <= next) {
                buckets.add(current);
                current += delta;
            }
            exp += digits;

            if (exp == 4) {
                digits = 1;
                denominator = 7;
            } else if (exp == 5) {
                denominator = 9;
            } else if (exp == 7) {
                denominator = 11;
            } else if (exp == 8) {
                denominator = 7;
            } else if (exp == 10) {
                denominator = 5;
            }
        }
        buckets.add(Long.MAX_VALUE);

        BUCKET_VALUES = new long[buckets.size()];
        for (int i = 0; i < buckets.size(); ++i) {
            BUCKET_VALUES[i] = buckets.get(i);
        }

        POWER_OF_4_INDEX = new int[powerOf4Index.size()];
        for (int i = 0; i < powerOf4Index.size(); ++i) {
            POWER_OF_4_INDEX[i] = powerOf4Index.get(i);
        }
    }

    private PercentileBuckets() {
    }

    /**
     * 为数组 Returns a copy of the bucket values array.
     *
     * @return {@link long[]}
     */
    public static long[] asArray() {
        long[] values = new long[BUCKET_VALUES.length];
        System.arraycopy(BUCKET_VALUES, 0, values, 0, BUCKET_VALUES.length);
        return values;
    }

    /**
     * 地图 Map the bucket values to a new array of a different type.
     *
     * @param c c
     * @param f f
     * @return {@link T}
     */
    public static <T> T[] map(Class<T> c, Function<Long, T> f) {
        @SuppressWarnings("unchecked")
        T[] values = (T[])Array.newInstance(c, BUCKET_VALUES.length);
        for (int i = 0; i < BUCKET_VALUES.length; ++i) {
            values[i] = f.apply(BUCKET_VALUES[i]);
        }
        return values;
    }

    /**
     * 得到 Return the value of the bucket at index {@code i}.
     *
     * @param i 我
     * @return long
     */
    public static long get(int i) {
        return BUCKET_VALUES[i];
    }

    /**
     * 长度 Returns the number of buckets.
     *
     * @return int
     */
    public static int length() {
        return BUCKET_VALUES.length;
    }

    /**
     * 指数 Returns the value the index of the bucket that should be used for {@code v}. The bucket value can be retrieved
     * using {@link #get(int)}.
     *
     * @param v v
     * @return int
     */
    public static int indexOf(long v) {
        if (v <= 0) {
            return 0;
        } else if (v <= 4) {
            return (int)v;
        } else {
            int lz = Long.numberOfLeadingZeros(v);
            int shift = 64 - lz - 1;
            long prevPowerOf2 = (v >> shift) << shift;
            long prevPowerOf4 = prevPowerOf2;

            int denominator = 3;
            if (shift < 4 && shift % 2 != 0) {
                shift--;
                prevPowerOf4 = prevPowerOf2 >> 1;
            } else if (shift >= 4 && shift < 5) {
                denominator = 7;
            } else if (shift >= 5 && shift < 7) {
                denominator = 9;
            } else if (shift >= 7 && shift < 8) {
                denominator = 11;
            } else if (shift >= 8 && shift < 10) {
                denominator = 7;
            } else if (shift >= 10) {
                denominator = 5;
            }

            long base = prevPowerOf4;
            long delta = base / denominator;
            int offset = (int)((v - base) / delta);
            int powerOf4Index = 0;
            if (shift < 4) {
                powerOf4Index = shift / 2;
            } else {
                powerOf4Index = shift - 2;
            }
            int pos = offset + POWER_OF_4_INDEX[powerOf4Index];
            return (pos >= BUCKET_VALUES.length - 1) ? BUCKET_VALUES.length - 1 :
                pos == POWER_OF_4_INDEX[powerOf4Index + 1] ? pos : pos + 1;
        }
    }

    /**
     * 桶 Returns the value of the bucket that should be used for {@code v}.
     *
     * @param v v
     * @return long
     */
    public static long bucket(long v) {
        return BUCKET_VALUES[indexOf(v)];
    }

}
